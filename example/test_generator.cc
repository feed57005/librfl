// Copyright (c) 2015 Pavel Novy. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "example/test_generator.h"

#include "package_manifest.h"

#include <iostream>
#include <fstream>
#include <algorithm>

namespace rfl {

char const *kFilePrologue = "// Generated by rfl-scan, do not modify\n\n";

void Gen::AddInclude(std::string const &inc, std::vector<std::string> &includes) {
  std::vector<std::string>::const_iterator it =
      std::find(includes.begin(), includes.end(), inc);
  if (it == includes.end())
    includes.push_back(inc);
}

int Gen::BeginPackage(Package const *pkg) {
  generated_package_ = pkg;
  package_upper_ = pkg->name();
  std::transform(package_upper_.begin(), package_upper_.end(),
                 package_upper_.begin(), ::toupper);
  std::string guard_name = pkg->name();
  guard_name += "_export";

  // generate _export.h
  hout_ << HeaderGuard(guard_name, true)
        << "#if defined(WIN32)\n"
        << "#if defined(" << package_upper_ << "_IMPLEMENTATION)\n"
        << "#define " << package_upper_ << "_EXPORT __declspec(dllexport)\n"
        << "#else\n"
        << "#define " << package_upper_ << "_EXPORT __declspec(dllimport)\n"
        << "#endif\n\n"
        << "#else // defined(WIN32)\n"
        << "#if defined(" << package_upper_ << "_IMPLEMENTATION)\n"
        << "#define " << package_upper_
        << "_EXPORT __attribute__((visibility(\"default\")))\n"
        << "#else\n"
        << "#define " << package_upper_ << "_EXPORT\n"
        << "#endif\n"
        << "#endif\n\n";
  hout_ << HeaderGuard(guard_name, false);

  std::string export_file = output_path_;
  export_file += "_export";
  export_file += h_file_suffix_;
  AddInclude(export_file, pkg_includes_);

  WriteStreamToFile(export_file, hout_);

  hout_.str(std::string());
  return 0;
}

std::string GetLibraryForName(std::string const &name, char const *suffix) {
  std::string lib_name;
#if defined(__APPLE__) || defined(__linux__)
  lib_name = "lib";
#endif
  lib_name += name;
  if (suffix != nullptr)
    lib_name += suffix;
#if defined(__APPLE__)
  lib_name += ".dylib";
#elif defined(__linux__)
  lib_name += ".so";
#elif defined(WIN32)
  lib_name += ".dll";
#endif
  return lib_name;
}

int Gen::EndPackage(Package const *pkg) {
  hout_ << HeaderGuard(pkg->name(), true);
  for (std::string const &include : pkg_includes_) {
    hout_ << "#include \"" << include << "\"\n";
  }
  hout_ << HeaderGuard(pkg->name(), false);

  out_ << "#include \"" << pkg->name() << ".rfl.h\"\n"
       << "#include \"example/object.h\"\n\n"
       << "extern \"C\" bool LoadPackage() {\n"
       << "  test::ClassRepository *repo = test::ClassRepository::GetSharedInstance();\n\n";
  for (Enum *e : enums_) {
    out_ << "  {\n"
         << "    test::Enum *" << e->name() << "_enum = new test::Enum();\n"
         << "    " << e->name() << "_enum->enum_name_ = \"" << e->name() << "\";\n";
    for (size_t j = 0; j < e->GetNumEnumItems(); ++j) {
      Enum::EnumItem const &item = e->GetEnumItemAt(j);
      out_ << "    " << e->name() << "_enum->items_.push_back(test::EnumItem(\""
           << item.id_ << "\",\"" << item.name_ << "\", " << item.value_
           << "));\n";
    }
    out_ << "    repo->RegisterEnum(" << e->name() << "_enum);\n";
    out_ << "  }\n";
  }
  for (std::pair<std::string, std::string> const &klass : classes_) {
    out_ << "  repo->RegisterClass(new " << klass.first << "());\n";
  }
  out_ << "  return true;\n"
       << "}\n";

  std::string path = output_path_;
  path += src_file_suffix_;
  WriteStreamToFile(path, out_);

  path = output_path_;
  path += h_file_suffix_;
  WriteStreamToFile(path, hout_);

  rfl::PackageManifest manifest;
  manifest.SetEntry("package.name", generated_package_->name().c_str());
  manifest.SetEntry("package.version", generated_package_->version().c_str());

  std::string lib_name = GetLibraryForName(output_path_, "_rfl");
  manifest.SetEntry("package.library", lib_name.c_str());

  for (int i = 0; i < generated_package_->GetImportNum(); i++) {
    std::string const &import = generated_package_->GetImportAt(i);
    std::string key = "imports.";
    key+= import;
    std::string val = GetLibraryForName(import, "_rfl");
    manifest.SetEntry(key.c_str(), val.c_str());
  }
  std::string manifest_file = output_path_;
  manifest_file += ".ini";
  manifest.Save(manifest_file.c_str());

  generated_package_ = nullptr;
  return 0;
}

int Gen::BeginFile(PackageFile const *file) {
  if (!file->is_dependency() && file->GetNumClasses()) {
    hout_.str(std::string());
    out_.str(std::string());
    src_includes_.clear();
    h_includes_.clear();

    std::string export_h = generated_package_->name();
    export_h += "_export";
    export_h += h_file_suffix_;
    AddInclude(export_h, h_includes_);

    std::string h_file = file->filename();
    h_file += h_file_suffix_;
    AddInclude(h_file, src_includes_);
    generated_file_ = file;
    return 0;
  }
  return 1;
}

int Gen::EndFile(PackageFile const *file) {
  if (file->is_dependency())
    return 1;
  generated_file_ = nullptr;

  // write header
  std::stringstream os;
  os << kFilePrologue << HeaderGuard(file->source_path(), true);
  for (std::string const &inc : h_includes_) {
    os << "#include \"" << inc << "\"\n";
  }
  os << "\n\n"
     << hout_.str()
     << HeaderGuard(file->source_path(), false);

  std::string h_file = file->source_path();
  h_file += h_file_suffix_;
  WriteStreamToFile(h_file, os);

  // write source
  os.str(std::string());
  os << kFilePrologue;
  for (std::string const &inc : src_includes_) {
    os << "#include \"" << inc << "\"\n";
  }
  os << "\n\n" << out_.str();

  std::string c_file = file->source_path();
  c_file += src_file_suffix_;
  WriteStreamToFile(c_file, os);

  hout_.str(std::string());
  out_.str(std::string());

  AddInclude(h_file, pkg_includes_);
  return 0;
}

int Gen::BeginNamespace(Namespace const *ns) {
  out_ << "\n";
  out_ << "namespace " << ns->name() << " {\n\n";

  hout_ << "namespace " << ns->name() << " {\n\n";

  for (size_t i = 0; i < ns->GetNumEnums(); ++i) {
    enums_.push_back(ns->GetEnumAt(i));
  }

  return 0;
}

int Gen::EndNamespace(Namespace const *ns) {
  hout_ << "} // namespace " << ns->name() << "\n\n";
  out_ << "} // namespace " << ns->name() << "\n\n";
  return 0;
}

int Gen::BeginClass(Class const *) {
  return 0;
}

static std::string GetFullClassName(Class const *clazz) {
  std::string ns="";
  Namespace const *current_ns = clazz->class_namespace();
  while (current_ns && current_ns->parent_namespace()) {
    ns.insert(0, "::");
    ns.insert(0, current_ns->name());
    current_ns = current_ns->parent_namespace();
  }
  ns+= clazz->name();
  ns+= "Class";
  return ns;
}

int Gen::EndClass(Class const *clazz) {

  AddInclude(clazz->header_file(), src_includes_);

  if (clazz->annotation().kind().compare("primitive") == 0) {
    hout_ << " // Primitive "<< clazz->name() << "\n\n";
    return 0;
  }

  std::string parent_class_name;
  std::string class_name = clazz->name();
  class_name += "Class";
  classes_.push_back(std::make_pair(GetFullClassName(clazz), clazz->name()));


  hout_ << "// generated from: " << clazz->header_file() << "\n";

  hout_ << "class " << package_upper_ << "_EXPORT " << class_name;
  if (clazz->super_class() != nullptr) {
    parent_class_name = clazz->super_class()->name();
    parent_class_name += "Class";
    hout_ << " : public " << parent_class_name;
    if (clazz->super_class()->package_file() != generated_file_) {
      std::string inc = clazz->super_class()->header_file();
      inc+= h_file_suffix_;
      AddInclude(inc, h_includes_);
    }
  } else {
    parent_class_name = "ObjectClass";
    hout_ << " : public test::ObjectClass";
    AddInclude("example/object.h", h_includes_);
  }
  hout_ << " {\n"
        << "public:\n"
        << "  static test::TypeId ID;\n\n"
        << "  " << class_name << "();\n"
        << "  virtual ~" << class_name << "() {}\n\n"

        << "  virtual test::Object *CreateInstance();\n"
        << "  virtual void ReleaseInstance(test::Object *obj);\n\n"

        << "protected:\n"
        << "  explicit " << class_name << "(char const *name, test::TypeId parent_id);\n"
        << "  virtual bool InitClassProperties(test::ClassInstance *instance);\n"
        << "};\n\n";

  out_ << "test::TypeId " << class_name << "::ID = -1;\n\n";

  // Default Constructor
  out_ << class_name << "::" << class_name << "() : "
          << parent_class_name << "(\"" << clazz->name() << "\", "
                               << parent_class_name << "::ID) {}\n\n";
  // Inherit Constructor
  out_ << class_name << "::" << class_name
       << "(char const *name, test::TypeId parent_id) : " << parent_class_name
       << "(name, parent_id) {}\n\n";

  // CreateInstance impl.
  out_ << "test::Object *" << class_name << "::CreateInstance() {\n"
       << "  return new " << clazz->name() << "();\n"
       << "}\n\n"

       << "void " << class_name << "::ReleaseInstance(test::Object *obj) {\n"
       << "  delete obj;\n"
       << "}\n\n";

  // InitClassProperties impl.
  out_ << "bool " << class_name << "::InitClassProperties(test::ClassInstance *instance) {\n"
       << "  " << class_name << "::ID = instance->class_id_;\n";
  if (clazz->GetNumFields() > 0) {
    out_ << "\n  // Properties\n\n";
  }
  for (size_t i = 0; i < clazz->GetNumFields(); i++) {
    Field *field = clazz->GetFieldAt(i);
    Annotation const &anno = field->annotation();
    std::string kind = anno.GetEntry("kind");
    char const *id = anno.GetEntry("id");
    char const *name = anno.GetEntry("name");
    if (kind.compare("number") == 0) {
      char const *default_value = anno.GetEntry("default");
      char const *min = anno.GetEntry("min");
      char const *max = anno.GetEntry("max");
      char const *step = anno.GetEntry("step");
      char const *page_step = anno.GetEntry("page_step");
      char const *page_size = anno.GetEntry("page_size");
      char const *precision = anno.GetEntry("precision");
      out_ << "  instance->AddProperty(new test::NumericProperty<" << field->type() << ">(\"" << id
           << "\", \"" << name << "\", " << field->offset() << ", class_id(), "
           << "rfl::AnyVar((" << field->type() << ")(" << default_value << ")), "
           << min << ", "
           << max << ", "
           << step << ", "
           << page_step << ", "
           << page_size << ", "
           << precision
           << "));\n";
    } else if (kind.compare("enum") == 0) {
      out_ << "  Enum *enum_" << id << " =\n"
           << "    test::ClassRepository::GetSharedInstance()->GetEnumByName(\""
           << field->type() << "\");\n";
      out_ << "  instance->AddProperty(new test::EnumProperty(enum_" << id
           << ", \"" << id << "\", \"" << name << "\", " << field->offset()
           << ", " << field->type() << "::" << anno.GetEntry("default")
           << "));\n";
    } else {
      char const *default_value = anno.GetEntry("default");
      std::stringstream any_value;
      if (field->type_qualifier().is_pointer()) {
        any_value << "(" << field->type() << ")";
        if (!default_value)
          default_value = "nullptr";
      } else if (field->type_qualifier().is_const()) {
        std::string no_const = field->type().substr(6);
        any_value << "(" << no_const << ")";
      } else {
        any_value << field->type();
      }
      any_value << "("<<(default_value ? default_value : "") << ")";
      out_ << "  instance->AddProperty(new test::Property(\"" << id << "\", \""
           << name << "\", " << field->offset() << ", class_id(), "
           << "rfl::AnyVar(" << any_value.str() << ")"
           << "));\n";
    }
  }

  if (clazz->GetNumMethods() > 0) {
    AddInclude("example/call_desc.h", src_includes_);
    out_ << "\n  // Methods\n\n";
  }
  for (size_t i = 0; i < clazz->GetNumMethods(); ++i) {
    Method *m = clazz->GetMethodAt(i);
    Argument *ret_arg = m->GetArgumentAt(0);
    out_ << "  static test::GenericCallDesc<" << clazz->name() << ", "
         << ret_arg->type() << "(" << clazz->name() << "::*)(";
    std::string signature = "x";
    for (size_t j = 1; j < m->GetNumArguments(); ++j) {
      Argument *arg = m->GetArgumentAt(j);
      switch(arg->kind()) {
        case Argument::kInput_Kind:
          signature += "i";
          break;
        case Argument::kOutput_Kind:
          signature+= "o";
          break;
        case Argument::kInOut_Kind:
          signature+= "a";
          break;
        case Argument::kReturn_Kind:
          signature+= "x";
          break;
      }
      out_ << arg->type() << (j < m->GetNumArguments() - 1 ? ", " : "");
    }
    out_ << ")> call_desc_" << m->name() << "(&" << clazz->name()
         << "::" << m->name() << ", \"" << signature << "\");\n";
    std::string const &human_name = m->annotation().GetEntry("name");
    out_ << "  test::Method *method_" << m->name() << " = new test::Method(\""
         << m->name() << "\", \"" << human_name << "\", class_id(), &call_desc_"
         << m->name() << ");\n";
    out_ << "  instance->AddMethod(method_" << m->name() << ");\n";
  }
  out_ << "  return true;\n"
       << "}\n\n";

  return 0;
}

} // namespace rfl

extern "C"
rfl::Generator *CreateGenerator() {
  return new rfl::Gen();
}
